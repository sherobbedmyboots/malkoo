# Simulating Advanced Post-Exploitation Agents 

In order to detect advanced agents, it helps to first be able to simulate their behaviors.  The AgentSim program was created to produce artifacts and conditions simliar to those resulting from the use of advanced post-exploitation tools on a system.  This document will walk through how a program like this can be used to better understand advanced TTPs and develop improved detection and response practices.

- [Agent Creation](#agent-creation)
	- [Staged Payloads](#staged-payloads)
	- [Stageless Payloads](#stageless-payloads)
- [Agent Evasion](#agent-evasion-techniques)
	- [Thread Start Address](#thread-start-address) 
	- [RWX Permissions](#rwx-permissions)
	- [Module Stomping](#module-stomping)
	- [Obfuscate and Sleep](#obfuscate-and-sleep)
- [Agent Operation](#agent-operation)
	- [Process Migration](#process-migration)
	- [Post-Exploitation Jobs](#post-exploitation-jobs)

<br>

AgentSim has three modes of operation: `create`, `evade`, and `operate`. In each mode, different tests can be performed on either a new process (by including `binPath`) or an existing process (by including `pid`):

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image003.png)<br><br>


## Agent Creation

Advanced post-exploitation tools use reflective DLLs to run in the memory of a hosting process and avoid writing files to disk. The AgentSim tool injects the following reflective DLL into a remote process which pops a message box to simulate an agent running in memory:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image001.png)<br><br>


The resulting message box:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image002.png)<br><br>


Two primary methods used for injecting the reflective DLL (agent) in memory are:

- [Staged Payloads](#staged-payloads)
- [Stageless Payloads](#stageless-payloads)

### Staged Payloads

A typical stager is a PowerShell cradle delivered via a container such as an Office doc or HTA.  Here is one created by [Empire](https://github.com/EmpireProject/Empire):

![](./images/Analyzing%20Malicious%20PowerShell%20Commands/image023.png)<br><br>

When it runs it downloads and runs the stage (agent) using the following process:

- Container writes stager to memory, passes execution to it (4 KB RWX)
- Stager downloads/writes XOR-encoded blob to memory, passes execution to it (204 KB RWX)
- XOR-Encoded blob decodes Reflective DLL in place, passes execution to it 
- Reflective DLL writes itself to memory, calls its own entry point (268 KB RWX) 

<br>

Here, AgentSim simulates the creation of an agent using a stager:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image004.png)<br><br>

The stager and agent can be found in memory using tools that can access process memory---here we use Process Hacker:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image005.png)<br><br>

The stager code is in the 4096 byte RWX segment:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image006.png)<br><br>

The encoded blob is in the 204 KB RWX segment:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image007.png)<br><br>

You can find the reflectively loaded DLL in the 268 KB RWX segment:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image008.png)<br><br>

Search this memory space and you can find where its strings are stored:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image009.png)<br><br>

While the process is running, you can practice using different detection techniques such as `Get-InjectedThread`:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image010.png)<br><br>


### Stageless Payloads

A second method of deploying an agent is using a stageless payload.  A good example of this is using [Cactus Torch](https://github.com/mdsecactivebreach/CACTUSTORCH) to create a container file that starts an arbitrary process and runs arbitrary shellcode:  

![](./images/Phishing%20To%20Injection%20Techniques/image033.png)<br><br>

This can be used to inject a reflective DLL (agent) into the memory of the target process with the following steps:

- Container writes reflective DLL to remote process, passes execution to it   (204 KB RWX)
- Reflective DLL writes itself to memory, calls its own entry point   (268 KB RWX) 

<br>

Here AgentSim simulates the creation of an agent by writing a stageless payload into the memory of a notepad process:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image011.png)<br><br>


This time, inside of `notepad.exe` are only the encoded blob (204 KB) and the reflective DLL (268 KB) running in memory--no stager:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image012.png)<br><br>

This is also easily detected by `Get-InjectedThread`:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image013.png)<br><br>


## Agent Evasion

Once running in memory, advanced post-exploitation tools have several ways of avoiding detection such as:

- [Thread Start Address](#thread-start-address) 
- [RWX Permissions](#rwx-permissions)
- [Module Stomping](#module-stomping)
- [Obfuscate and Sleep](#obfuscate-and-sleep)


### Thread Start Address

Reflectively injected DLLs are not mapped to a file on disk so many detection tools like `Get-InjectedThread` search for threads running in memory that are not associated with a module (module-less threads).

One way to bypass this detection is to start a thread using the address of a known library such as LoadLibraryA, then pause the thread, change it to the location of the reflective DLL, and resume thread execution.

AgentSim uses this technique in `evade` mode with the `thread` test:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image015.png)<br><br>

The threads tab shows that thread 16344 started in the LoadLibraryA module:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image014.png)<br><br>

But this thread is actually running the reflective DLL in memory:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image016.png)<br><br>

And now `Get-InjectedThread` cannot detect it:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image017.png)<br><br>


### RWX Permissions

Another way to evade tools monitoring for injection is to avoid setting RWX permissions for the memory segment containing the reflective DLL.

AgentSim uses this technique in `evade` mode with the `perms` test:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image018.png)<br><br>

This runs the agent in a memory segment with EXECUTE and READ permissions (RX):

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image019.png)<br><br>

This time, `Get-InjectedThread` correctly detects this and reports the permissions the memory was allocated with (`PAGE_READWRITE`) along with the current permissions (`PAGE_EXECUTE_READ`):

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image020.png)<br><br>

Keep in mind when using this test, this can only be performed with 32 bit processes.  64-bit processes have execution protection in effect by default.

In BINPATH mode a 32 bit process is created, but in PID mode you must provide the PID of a 32 bit process for this to work. 

### Module Stomping

Module stomping is when a remote process is made to import a legitimate, but unnecessary DLL so that it can be overwritten with the reflective DLL's code.

AgentSim uses this technique in `evade` mode with the `stomp` test:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image036.png)<br><br>


A normal `notepad.exe` process does not load the `BingMaps.dll` DLL:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image037.png)<br><br>


But in this one that AgentSim created, you can now see it was mapped into memory at address `0x7ffd63a10000` :

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image038.png)<br><br>

Once the address of this DLL is discovered, AgentSim replaces the `BingMaps.dll` code with the code of our reflective DLL:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image039.png)<br><br>

Now the Agent DLL code is at that address, but the process still reports that `BingMaps.dll` is at that address:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image038.png)<br><br>

This technique is used to bypass detection tools that search for module-less threads like `Get-InjectedThread`.


### Obfuscate and Sleep

Injected DLLs may have many strings/indicators of an executable in memory such as exports (`_ReflectiveLoader@4`), file headers (`MZ`), and other suspicious strings that are signs of injected code.  These can be hidden from many detection tools if the agent obfuscates itself (and "sleeps") when it is not actively performing tasks.

AgentSim uses this technique in `evade` mode with the `sleep` test:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image021.png)<br><br>

The following process then repeats:

-	Agent is written in memory and runs for 5 seconds
- 	Agent is overwritten with random bytes and "sleeps" for 13 seconds

<br>

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image022.png)<br><br>

Here is what memory looks like during the 5 seconds the reflective DLL runs:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image023.png)<br><br>

After 5 seconds, click the `Re-read` button and see that this memory space has been overwritten with random bytes to avoid memory scanning tools:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image024.png)<br><br>


## Agent Operation

When an agent is running on a victim system, a common technique is to copy the agent (migrate) to a less suspicious process---one that will have a long life and is known to use the network to communicate to external systems.  

The two primary actions of an advanced post-exploitation agent are:

- [Migration and Session Passing](#migration-and-session-passing)
- [Post-Exploitation Jobs](#post-exploitation-jobs)

### Migration and Session Passing

Advanced post-exploitation agents have the ability to inject a second agent into a remote process.  The second agent can have the same configuration (migration) or be configured with a different profile (session passing).

This can be accomplished by spawning a new process to inject the new agent into or by injecting the new agent into an existing process.

AgentSim uses this technique in `operate` mode with the `migrate` test:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image025.png)<br><br>

This injected the reflective DLL into the `iexplore.exe` process with PID 14284:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image026.png)<br><br>

Since no evasion techniques were used, this is detected by `Get-InjectedThread`:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image027.png)<br><br>


### Post-Exploitation Jobs

Post-exploitation jobs are agent tasks that are usually run in remote processes and report back results to the agent upon completion.  The remote process is injected like above but instead of injecting the agent, custom PowerShell scripts and .NET assemblies are injected to perform a specific task.

The specific task could be to gather credentials with a [PowerShell](#powershell) script such as [Invoke-Mimikatz](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-Mimikatz.ps1) or with the a [.NET Assembly](#.net-assembly) such as [SafetyKatz](https://github.com/GhostPack/SafetyKatz).  Upon completion, the results of the job are sent back to the agent and the temporary process exits.


#### .NET Assemblies

Because of improvements in PowerShell command logging and other obfuscation and execution detection techniques, many PowerShell scripts from the PowerSploit collection have been rewrittten in C# and compiled as .NET assemblies.  A remote process is made to start the .NET CLR and then load and run a .NET assembly.

[GhostPack](https://posts.specterops.io/ghostpack-d835018c5fc4) is a collection of C# programs that have the same functionality as many PowerSploit scripts but do not leave the same artifacts as they are executed as compiled code inside the target process.


AgentSim uses this technique in `operate` mode with the `tempjob` test and `dotnet` option.  Pick a process that doesn't normally load the .NET CLR such as Task Manager (`taskmgr.exe`):

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image031.png)<br><br>

Inspecting the `Modules` tab shows the .NET runtime has been loaded into the process:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image032.png)<br><br>

Also unusual is the presence of this executable:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image033.png)<br><br>

Inspecting the `.NET Assemblies` tab shows the `DotnetJob.exe` assembly and its dependencies:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image034.png)<br><br>


#### PowerShell

With the ability to inject a .NET assembly into any remote process, an agent can inject a .NET assembly that imports and runs PowerShell exploitation scripts such as those in the `PowerSploit` collection. 

Projects like [PowerPick](https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerPick) allow agents to reflectively load a DLL into any process so that a .NET assembly can run arbitrary PowerShell scripts without calling `powershell.exe` ([Unmanaged PowerShell](./Detecting%20Unmanaged%20Powershell.md)).

[ReflectivePick](https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerPick/ReflectivePick) is the DLL written in C++ and [SharpPick](https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerPick/SharpPick) is the .NET assembly that loads the Automation dll which runs PowerShell.

AgentSim uses this technique in `operate` mode with the `tempjob` test and `ps` option:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image028.png)<br><br>

Here, the Paint program is made to run the PowerShell command "ls":

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image029.png)<br><br>

Inspecting the `Modules` tab shows in addition to .NET libraries, PowerShell DLLs have also been loaded into the process:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image030.png)<br><br>

Inspecting the `.NET Assemblies` tab shows the `PsJob.exe` assembly and its dependencies:

![](./images/Simulating%20Advanced%20Post-Exploitation%20Agents/image035.png)<br><br>



## Summary

Creation
- Agents can be created using stager or stageless
- Artifacts in the injected process include the stager (4 KB), encoded blob (204 KB), and running agent (268 KB) if no cleanup is performed

Evasion
- Module-less threads can be used to identify injected code
- Private memory with RWX permissions also may indicate injection
- Agents can import legitimate DLLs, then overwrite with their own code
- Agents can obfuscate themselves while not actively performing tasks to avoid detection

Operation
- Agents will likely migrate to long-living, less suspicious processes
- Most post-exploitation jobs are executed by spawning temporary processes and injecting either .NET assemblies and/or PowerShell scripts to accomplish specific tasks

<br>

Currently, [AgentSim.exe]() must run out of the $env:PUBLIC directory with the following files present:

```
DotnetJob.exe
PsJob.exe
remote_Dotnet_Inject.dll
remote_Ps_Inject.dll
```
