# Analysis of Fareit Malware


Fareit, also known as Pony, is a family of malware observed since 2011 that steals system information and credentials from email, browser, and file transfer and storage applications. It has also been observed downloading additional malware that hooks API addresses and inject code into webpages to monitor online banking activities.

We observed the sample `RFQ For Supply Of Materials - Doha Metro (Phase 1) Project - (GMT WAREHOUSES @ INDUSTRIAL AREA).exe` (abbreviated as `RFQ.exe`) steal the following from a test system:

- FTP hosts, username, and passwords
- Cookies, usernames, and passwords stored in browsers
- Account data for cloud storage services
- Email usernames and passwords


Summary File Behavior:

- The binary is written in Visual Basic to hinder static analysis and reverse engineering
- When run, it attempts to detect a debugger and exits if one is found
- It then attempts to detect evidence of a sandbox environment and exits if it is
- If these checks pass, it spawns a copy of itself and uses process hollowing to unpack a second stage binary
- The second stage binary which exists only in memory begins credential stealing and password guessing
- Data discovered is collected, compressed using aPLib, and encrypted using RC4
- The encrypted, stolen data is sent to the attacker-controlled server using HTTP POSTs
- The second stage binary writes a .bat file that deletes the malware and itself


Each of the malware's capabilities is carried out by different combinations of Windows API, third party, and custom functions: 

|Capabilities|Functions|
|-|-|
|[Anti-Debugging Techniques](anti-debugging-techniques)|[IsDebuggerPresent](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680345.aspx), [NtGlobalFlag](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags)|
|[Sandbox Evasion Techniques](#sandbox-evasion-techniques)|[GetTickCount](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724408%28v=vs.85%29.aspx), [GetCursorPos](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getcursorpos)| 
|[Process Hollowing](#process-hollowing)|[VirtualAllocEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890.aspx), [UnmapViewOfFile](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366882.aspx)|
|[Password Guessing](#password-guessing)|[NetUserEnum](https://docs.microsoft.com/en-us/windows/desktop/api/lmaccess/nf-lmaccess-netuserenum), [LogonUserA](https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-logonusera)|
|[Credential Stealing](#credential-stealing)|[CreateFile](https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea), [MapViewOfFile](https://msdn.microsoft.com/en-us/library/Aa366761.aspx)|
|[Compression and Encryption](#compression-and-encryption)|[aPLib](https://documentation.help/aPLib/index.html), [RC4](https://en.wikipedia.org/wiki/RC4)|
|[Transmitting Stolen Information](#transmitting-stolen-information)|[connect](https://docs.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-connect), [send](https://docs.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-send)| 
|[Clean Up](#clean-up)|[WriteFile](https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-writefile), [ShellExecuteA](https://docs.microsoft.com/en-us/windows/desktop/api/shellapi/nf-shellapi-shellexecutea)|

<br>

To better understand how the malware operates, let's look at what each function is doing.

## Anti-Debugging Techniques

Load the sample in x64dbg debugger and set a breakpoint for the [IsDebuggerPresent](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680345.aspx) function by typing `bp IsDebuggerPresent`.  Hit `F9` a few times until the breakpoint is hit, then press `Alt-F9` so the function executes and execution returns back to the `RFQ.exe` process.

When the process is being debugged, a call to the [IsDebuggerPresent](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680345.aspx) function will return a value of `1` which you can find in the `EAX` register.  We can change this by changing the value to `0` before it is checked by the malware.

After this, the malware checks the [NtGlobalFlag](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags).  When a process is being debugged, there will be a value of `0x70` at the memory address  `fs:[30]+0x68`.  We can change this by typing `fs:[30]+0x68` in the console and changing it to `0x00`.

These both can be fixed by enabling x64dbg's [HideDebugger](https://x64dbg.readthedocs.io/en/latest/commands/misc/HideDebugger.html) option by typing `dbh` in the console immediately after loading or attaching to a process.

## Sandbox Evasion Techniques

[GetTickCount](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724408%28v=vs.85%29.aspx) is used to track the time it takes for different portions of the code to execute.  This malware periodically checks the time twice and then checks to see if the time passed is greater than 1500 milliseconds and if so, terminates the process.  To overcome this, set a breakpoint on the function with `bp GetTickCount`, and when it is followed by a check, change the result to a value of `1499` or less.  x64dbg's [HideDebugger](https://x64dbg.readthedocs.io/en/latest/commands/misc/HideDebugger.html) option also bypasses this technique.

[GetCursorPos](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getcursorpos) is used to track mouse movements while certain operations are performed by the malware.  If the mouse isn't moved and this function is called twice, they will return the same value and the code will terminate the process.  You can change these values too but this function gets called many times.  The easy way around this is to just make sure you move your mouse a few times if the malware is actively running.


## Process Hollowing

After the anti-debugging and anti-sandbox code is bypassed, the `RFQ.exe` process will spawn a copy of itself which we need to debug.  A quick way to get to this point is:

- Open `RFQ.exe` in x64dbg
- Type `dbh` to hide debugger
- Type `bp CreateProcessInternalW` to set breakpoint
- Press `F9` to get to Entry Point
- Press `F9` to begin running the program
- When the breakpoint at `CreateProcessInternalW` is reached, press `Alt + F9` until you see a second process created (use Process Hacker)
- Start a second x64dbg process and attach to the second `RFQ.exe` process
- Type `dbh` in second x64dbg window to hide debugger from second `RFQ.exe` process
- In the first x64dbg window, press `F9` until the first `RFQ.exe` process exits and then close the x64dbg window

Now you should have the second `RFQ.exe` process paused in the debugger.  We will now set breakpoints on the [VirtualAllocEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890.aspx) and [UnmapViewOfFile](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366882.aspx) functions to observe the malware perform process hollowing.

- Type `bp VirtualAllocEx` 
- Type `bp UnmapViewOfFile` 
- Press `F9` to run the program


When the breakpoint is reached, we can see the arguments the malware is passing to the [VirtualAllocEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890.aspx) function by looking on the stack:

![](images/Fareit%20Analysis/image021.png)<br><br>

To see what each of these values means, look at the documentation for the function:

```powershell
LPVOID WINAPI VirtualAllocEx(
  _In_     HANDLE hProcess,
  _In_opt_ LPVOID lpAddress,
  _In_     SIZE_T dwSize,
  _In_     DWORD  flAllocationType,
  _In_     DWORD  flProtect
);
```
<br>

It is allocating 2K at the image base address `00400000`.

Press `Alt-F9` to run the function and get back to the `RFQ.exe` module, then inspect the value returned in the `EAX` register.  Right click on this value and select `Follow in Dump`.  You should see the empty memory space that was just allocated.

Press `F9` to continue running the program.  Another breakpoint on [VirtualAllocEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890.aspx) and we'll do the same thing---Press `Alt-F9` to run until user code, inspect the value returned in the `EAX` register, and right click on this value --> `Follow in Dump`.


Press `F9` to continue.  The next breakpoint should be for [UnmapViewOfFile](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366882.aspx). It only takes one argument, the base address:

```powershell
BOOL WINAPI UnmapViewOfFile(
  _In_ LPCVOID lpBaseAddress
);
```

<br>

Note the argument being passed by the malware:

![](images/Fareit%20Analysis/image022.png)<br><br>

The file at `0x00400000` will be unmapped.  Go to that address in the dump by typing `dump 00400000` then press `Alt + F9` to execute the function and watch the image base be removed from memory.

Press `F9` to continue and the [VirtualAllocEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890.aspx) function is called again.  Inspect its arguments:

![](images/Fareit%20Analysis/image023.png)<br><br>

Press `Alt-F9` until the function completes and the second stage executable is written into `0x00400000` as the base image.

Now that the second stage binary is unpacked and running in memory, we can dump it so we can perform static analysis on the unpacked executable.  Go to the `Memory Map` tab, right click on the memory segment containing the base image (`0x00400000`), and select `Dump Memory to File`.

Open in PEStudio:

![](images/Fareit%20Analysis/image024.png)<br><br>

Examining the strings reveals a list of common passwords:

![](images/Fareit%20Analysis/image025.png)<br><br>

## Password Guessing

To perform password guessing, the [NetUserEnum](https://docs.microsoft.com/en-us/windows/desktop/api/lmaccess/nf-lmaccess-netuserenum) function is first used to enumerate all the user accounts on the system.

Set a breakpoint on this function with `bp NetUserEnum`.  When the breakpoint hits, press `Alt-F9` to come back to the malware's code and see what value is returned.

```powershell
NET_API_STATUS NET_API_FUNCTION NetUserEnum(
  LPCWSTR servername   OPTIONAL,
  DWORD                level,
  DWORD                filter,
  LPBYTE               *bufptr,
  DWORD                prefmaxlen,
  LPDWORD              entriesread,
  LPDWORD              totalentries,
  PDWORD resume_handle OPTIONAL
);
```

<br>

Once the accounts have been enumerated, the [LogonUserA](https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-logonusera) function is used to carry out password attacks on each account using a list of common passwords.

Set a breakpoint on this function with `bp LogonUserA`.  When the breakpoint hits, examine the arguments being passed:

```powershell
BOOL LogonUserA(
  LPCSTR  lpszUsername,
  LPCSTR  lpszDomain,
  LPCSTR  lpszPassword,
  DWORD   dwLogonType,
  DWORD   dwLogonProvider,
  PHANDLE phToken
);
```

<br>

Press `F9` to call the function with the username and password provided by the malware.  Continue pressing `F9` to see each different username/password combination.

First it tries every password in the list using the built-in account for homegroup access to the computer:

![](images/Fareit%20Analysis/image013.png)<br>
![](images/Fareit%20Analysis/image014.png)<br><br>

Then it cycles through the same password list with the Guest account:

![](images/Fareit%20Analysis/image015.png)<br>
![](images/Fareit%20Analysis/image016.png)<br><br>

And finally with the Administrator account:

![](images/Fareit%20Analysis/image017.png)<br>
![](images/Fareit%20Analysis/image018.png)<br><br>

You can view all of these failed logon attempts in the Security Logs.


## Credential Stealing

The malware also uses a list of filenames and registry keys that are known to store credentials and other sensitive information.  The [CreateFile](https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea) function is used to request a handle to each file on the list so it can be read and mapped into memory.

Set a breakpoint for this function with `bp CreateFile` and when it hits examine the arguments being passed.

```powershell
HANDLE CreateFileA(
  LPCSTR                lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);
```

<br>

Use `F9` to see each time the function is called using the list of sensitive files.

To give it some unique credentials to find, I installed Filezilla using `choco install filezilla -y`, used it to generate some fake data, and checked `C:\Users\jcasy\Appdata\Roaming\Filezilla\recentservers.xml` to confirm it contained usernames, server names, and passwords that the malware could steal:

![](images/Fareit%20Analysis/image012.png)<br><br>

When this file is discovered, it is mapped into memory using the [MapViewOfFile](https://msdn.microsoft.com/en-us/library/Aa366761.aspx) function.  Set a breakpoint on this function and examine the arguments being passed:

```powershell
LPVOID WINAPI MapViewOfFile(
  _In_ HANDLE hFileMappingObject,
  _In_ DWORD  dwDesiredAccess,
  _In_ DWORD  dwFileOffsetHigh,
  _In_ DWORD  dwFileOffsetLow,
  _In_ SIZE_T dwNumberOfBytesToMap
);
```

<br>

Press `Alt-F9` to execute the function and examine the value returned in the `EAX` register.  This contains the starting address of the mapped view of the file in memory.

## Transmitting Stolen Information

The [connect](https://docs.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-connect) function is used to perform a three way handshake with the C2 server.  The function passes the following arguments:

```powershell
int WSAAPI connect(
  SOCKET         s,
  const sockaddr *name,
  int            namelen
);
```

<br>

Set a breakpoint for this function and when it hits open up Network Monitor.  Start capturing traffic and press `Alt + F9` to execute the function.  You should see the SYN, SYN-ACK, and ACK:

![](images/Fareit%20Analysis/image003.png)<br><br>

The [send](https://docs.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-send) function is used to perform the HTTP POST containing the encrypted data.

```powershell
int WSAAPI send(
  SOCKET     s,
  const char *buf,
  int        len,
  int        flags
);
```

<br>

Set a breakpoint for it, press `F9` to continue the program, and when the breakpoint hits press `Alt + F9` to complete it.  You should then see the POST request sent:

![](images/Fareit%20Analysis/image004.png)<br><br>

Inspect this packet as it contains the encrypted data sent to attacker server:

![](images/Fareit%20Analysis/image007.png)<br><br>

Copy and paste this encrypted payload into a file:

![](images/Fareit%20Analysis/image006.png)<br><br>

Or find it in memory and dump it:

![](images/Fareit%20Analysis/image005.png)<br><br>

Now that we have captured the encrypted blob being sent to the C2 server, we can reverse the compression and encryption used.


## Compression and Encryption

Fareit samples generally compress data once, then encrypt it twice--once with a personal key and again with a randomly generated key.  So we can take the encrypted blob from the POST payload and start working backwards from there.

First examine the HTTP POST payload in hex format.  The first 4 bytes are the encryption key that's being used.  In this case we're using [CyberChef's](https://gchq.github.io/CyberChef/) RC4 recipe to decrypt the payload using the first four bytes, `FF070FE5`, as the key:

![](images/Fareit%20Analysis/image020.png)<br><br>

The CRYPTED0 file header is an indication of successful decryption.  Now we need to decrypt this file (not including the "CRYPTED0" header) using the personal key which is hard-coded in the file and is usually found just before the C2 URL:

![](images/Fareit%20Analysis/image027.png)<br><br>

Using the key `mkv101` with the RC4 decrypt recipe gives us another file with a PKDFILE0 file header:

![](images/Fareit%20Analysis/image019.png)<br><br>

This is a compressed version of the malware's PWDFILE and you can start to make out some of the information that was stolen in this output.  We can decompress this file using the [aPLib](https://documentation.help/aPLib/index.html) library to recover the original file that was mapped in memory before compression:

![](images/Fareit%20Analysis/image026.png)<br><br>


## Clean Up

This sample covers its tracks by writing a BAT file using the [WriteFile](https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-writefile) function that deletes the malware and itself.

Set a breakpoint on this function and examine the arguments being passed:

```powershell
BOOL WriteFile(
  HANDLE       hFile,
  LPCVOID      lpBuffer,
  DWORD        nNumberOfBytesToWrite,
  LPDWORD      lpNumberOfBytesWritten,
  LPOVERLAPPED lpOverlapped
);
```

<br>

The function is provided a buffer containing what will be written and the name of the file which is a random seven digit number.  We can inspect the address in memory to see each one:

![](images/Fareit%20Analysis/image008.png)<br><br>


The [ShellExecuteA](https://docs.microsoft.com/en-us/windows/desktop/api/shellapi/nf-shellapi-shellexecutea) function is then used to run the BAT file.  Set a breakpoint and examine the arguments passed to it:

```powershell
HINSTANCE ShellExecuteA(
  HWND   hwnd,
  LPCSTR lpOperation,
  LPCSTR lpFile,
  LPCSTR lpParameters,
  LPCSTR lpDirectory,
  INT    nShowCmd
);
```

<br>

The RFQ.exe file is provided as the lpParameters argument:

![](images/Fareit%20Analysis/image009.png)<br><br>

## Summary

This Fareit sample attempts to prevent analysis in several ways:

- Wrapped in a Visual Basic program so that static analysis doesn't reveal its imports
- Once it runs, it exits upon seeing evidence of debugging and sandbox environments
- When it unpacks the second stage executable, it runs it only in memory via process hollowing
- It compresses and encrypts communications to its C2 server
- It deletes itself from the system when credential stealing is complete

Being able to spot these techniques in use and bypass them to perform analysis is key to a quick and efficient response.  Practice several different ways you could identify the use of each one of these techniques using the `RFQ.exe` sample.